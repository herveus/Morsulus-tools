#!/usr/bin/perl -w
$|++;
use strict;
#use diagnostics;
# see categorize.pod for detailed docs

# usage: $0 -i dbfile -c category_file
#	-i names the database file being categorized - required
#	-c names the category file - defaults to './mycat'
# the category file must be of a form generated by mk_cat_file

use POSIX qw(ceil);
use Tk;
use Getopt::Std;
require Tk::NoteBook;
require Tk::LabEntry;
require Tk::DialogBox;
require Tk::HList;
require Tk::ROText;

use Data::Dumper;
$Data::Dumper::Indent = 1;

getopt('ic');
die "-i database_file required but missing" unless defined $Getopt::Std::opt_i;
die "database file $Getopt::Std::opt_i not readable" unless -r $Getopt::Std::opt_i;

require 'mycat' unless defined($Getopt::Std::opt_c);
require $Getopt::Std::opt_c if defined($Getopt::Std::opt_c);

print STDERR "Initializing\n";

my %categories = &categories;
my %set_name = &set_name;
my %set_names = &set_names;
my @feature_names = &feature_names;
my %xref = &xrefs;
my %group = &group_hash;
my @group = &group_array;
my %heading = map {$categories{$_}->{heading} => $_} keys %categories;
my %current_descs; # key is heading, value is list of descs; reset when current item changes
my @items; # each item is line from file

my $current_item;
my $max_item;
my $number_of_items;

print STDERR "Make visuals\n";
my $mw = new MainWindow;
my $font = '-b&h-lucidatypewriter-medium-r-normal-sans-10-100-75-75-m-60-iso8859-1';

my $item_f = $mw->Frame(-borderwidth => 2,
	-relief => 'ridge',
	)->pack(qw/-side top -fill x -expand yes/);
my $control_f = $mw->Frame(-borderwidth => 2,
	-relief => 'ridge',
	)->pack(qw/-side bottom -fill x -expand yes/);
my $cat_nb = $mw->NoteBook(
	-font => $font,
	)->pack(qw/-side top -fill both -expand yes/);

my ($name, $blazon);
$item_f->LabEntry(-label => 'Name',
	-labelPack => [qw/-side left -anchor w/],
	-width => 60,
	-textvariable => \$name,
	-font => $font,
	-relief => 'flat',
	-state => 'disabled',
	)->pack(qw/-side top -fill x -expand yes -anchor w/);
my $blazon_rot = $item_f->ROText(
	-width => 120,
	-height => 2,
	-font => $font,
	-wrap => 'word',
	)->pack(qw/-side top -fill x -expand yes -anchor w/);
my $msg;
my $name_entry = $item_f->LabEntry(-label => 'Name search:',
	-labelPack => [qw/-side left -anchor w/],
	-width => 60,
	-textvariable => \$msg,
	-font => $font,
	)->pack(qw/-side right -fill x -expand yes -anchor e/);
$name_entry->bind('<Return>', \&Find_Item);

$control_f->Button(-text => 'First',
	-command => \&First_Item,
	)->pack(qw/-side left/);
$control_f->Button(-text => 'Prev',
	-command => \&Prev_Item,
	)->pack(qw/-side left/);
$control_f->Button(-text => 'Next',
	-command => \&Next_Item,
	)->pack(qw/-side left/);
$control_f->Button(-text => 'Last',
	-command => \&Last_Item,
	)->pack(qw/-side left/);
$control_f->Button(-text => 'Find',
	-command => \&Find_Item,
	)->pack(qw/-side left/);
$control_f->Button(-text => 'Refine',
	-command => \&Refine_Cats,
	)->pack(qw/-side left -padx 15/);
$control_f->Button(-text => 'Look Up Equivalence',
	-command => \&Find_Synonym,
	)->pack(qw/-side left/);

$control_f->Button(-text => 'Quit',
	-command => \&Quit,
	)->pack(qw/-side right/);

$control_f->Button(-text => 'Abort',
	-command => \&exit,
	)->pack(qw/-side right/);

$control_f->Button(-text => 'Save',
	-command => \&Save,
	)->pack(qw/-side right/);

print STDERR "Setting up categories\n";

my %tabs;
my %frames;
foreach my $tab (@group)
{
	my $count = scalar(@{$group{$tab}});
	my $pages = ceil($count/90);
	my $items_per_page = ceil($count/$pages);
	my $cols_per_page = ceil($items_per_page/18);
	my $items_per_col = ceil($items_per_page/$cols_per_page);
	$items_per_page = $items_per_col * $cols_per_page;
	
	foreach my $tabno (1..$pages)
	{
		my $tabname = $tab;
		$tabname .= " $tabno" if $tabno > 1;
		
		$tabs{$tabname} = $cat_nb->add($tabname, -label => $tabname,
			-anchor => 'center',
			);

		foreach my $f (0..$cols_per_page-1)
		{
			$frames{$tabname}[$f] = $tabs{$tabname}->Frame->pack(qw/-side left -anchor n -expand yes -fill y/);
			
			foreach my $cat (($tabno-1)*$items_per_page+$f*$items_per_col .. ($tabno-1)*$items_per_page+$f*$items_per_col+$items_per_col-1)
			{
				last if $cat >= $count;
				my $cat_name = $group{$tab}[$cat];
				$frames{$tabname}[$f]->Checkbutton(-text => $cat_name,
					-font => $font,
					-variable => \$categories{$cat_name}->{value},
					-command => sub 
						{ 
							if ($categories{$cat_name}->{value})
							{
								push @{$current_descs{$f}}, $cat_name;
							}
							else
							{
								delete $current_descs{$f};
							}
						},
					)->pack(qw/-side top -anchor w/);
				print STDERR "$tabname $cat_name                                   \r";
			}
		}
		foreach my $f ($cols_per_page..5)
		{
			$frames{$tabname}[$f] = $tabs{$tabname}->Frame->pack(qw/-side left -anchor n -expand yes -fill y/);
		}
	}
}

print STDERR "\n";

open DBFILE, $Getopt::Std::opt_i or die "?! Cannot open database file $Getopt::Std::opt_i: $!";
@items = <DBFILE>;
chomp @items;
close DBFILE;

$max_item = $#items;
$number_of_items = @items;
$current_item = 0;

$item_f->LabEntry(-label => 'Item',
	-labelPack => [qw/-side left -anchor w/],
	-textvariable => \$current_item,
	-width => 6,
	-state => 'disabled',
	-relief => 'flat',
	)->pack(qw/-side left -anchor w/);
$item_f->LabEntry(-label => 'of',
	-labelPack => [qw/-side left -anchor w/],
	-textvariable => \$number_of_items,
	-width => 6,
	-state => 'disabled',
	-relief => 'flat',
	)->pack(qw/-side left -anchor w/);
	
First_Item();

MainLoop;
exit;

sub First_Item
{
	Save_Indexing($current_item) if $current_item;
	foreach my $i (1..$number_of_items)
	{
		my @parts = split(/[|]/, $items[$i-1]);
		next unless $parts[2] =~ /^[abds]$/;
		$current_item = $i;
		last;
	}
	reset_buttons($current_item);
}
		
sub Last_Item
{
	Save_Indexing($current_item) if $current_item;
	foreach my $i (reverse 1..$number_of_items)
	{
		my @parts = split(/[|]/, $items[$i-1]);
		next unless $parts[2] =~ /^[abds]$/;
		$current_item = $i;
		last;
	}
	reset_buttons($current_item);
}
		
sub Next_Item
{
	Save_Indexing($current_item) if $current_item; 
	foreach my $i ($current_item+1..$number_of_items, 1..$current_item)
	{
		my @parts = split(/[|]/, $items[$i-1]);
		next unless $parts[2] =~ /^[abds]$/;
		$current_item = $i;
		last;
	}
	reset_buttons($current_item);
}

sub Prev_Item
{ 
	Save_Indexing($current_item) if $current_item; 
	foreach my $i (reverse($current_item..$number_of_items, 1..$current_item-1))
	{
		my @parts = split(/[|]/, $items[$i-1]);
		next unless $parts[2] =~ /^[abds]$/;
		$current_item = $i;
		last;
	}
	reset_buttons($current_item);
}

sub Find_Item
{
	Save_Indexing($current_item) if $current_item; 
	foreach my $i ($current_item+1..$number_of_items, 1..$current_item)
	{
		my @parts = split(/[|]/, $items[$i-1]);
		next unless $parts[2] =~ /^[abds]$/;
		next unless $parts[0] =~ /$msg/;
		$current_item = $i;
		last;
	}
	reset_buttons($current_item);
	
}

sub Save_Indexing
{
	my $current_item = shift;
	my @parts = split(/[|]/, $items[$current_item-1]);
	my @indices = ();
	#print STDERR "Save_Indexing found: ", Dumper(\%current_descs);
	foreach my $f (keys %categories)
	{
		next unless $categories{$f}->{value};
		#print STDERR "$f is $categories{$f}->{value}; current_descs{$f}", 
		#	exists $current_descs{$f} ? 'exists' : "doesn't exist";
		#exists $current_descs{$f} and print STDERR "; it ", ref($current_descs{$f}) ? "is a ref to ".ref($current_descs{$f}) : "is not a ref";
		#print STDERR "\n";
		if (exists $current_descs{$f} and ref($current_descs{$f}) and ref($current_descs{$f}) eq 'ARRAY')
		{
			push @indices, @{$current_descs{$f}};
		}
		else
		{
			push @indices, $f;
		}
		#print STDERR "Saved ", join("|", @{$current_descs{$f}}), " from category $f\n";
	}
	#print STDERR "\n";
	$items[$current_item-1] = join("|", @parts[0..4]);
	$items[$current_item-1] .= '|'.join("|", sort @indices) if @indices;
}

sub reset_buttons
{
	my $current_item = shift;
	my @indexing;
	($name, undef, undef, $blazon, undef, @indexing) = split(/[|]/, $items[$current_item-1]);
	
	%current_descs = ();
	foreach my $i (sort @indexing)
	{
		my ($head, @rest) = split(/:/, $i);
		unless (exists($categories{$head}))
		{
			$head = $heading{$head};
		}
		push @{$current_descs{$head}}, join(":", $head, @rest);
		#print STDERR 'reset_buttons: push @{$current_descs{', $head, '}}, ', $i, "\n";
	}
	
	foreach my $f (keys %categories)
	{
		$categories{$f}->{value} = exists($current_descs{$f}) ? 1 : 0;
	}
	
	$blazon_rot->delete('1.0', 'end');
	$blazon_rot->insert('1.0', $blazon);
}

sub Save
{
	Save_Indexing($current_item);
	unless (open(DBFILE, ">".$Getopt::Std::opt_i))
	{
		print STDERR "Cannot open database file $Getopt::Std::opt_i for writing: $!";
		return 0;
	}
	print DBFILE join("\n", @items), "\n";
	close DBFILE;
	return 1;
}

sub Quit
{
	Save_Indexing($current_item);
	Save;
	exit;
}

# here be desc refinement foo
{
	my $refine_dlog; # the DialogBox
	my $desc_list; # the HList of descs
	my @indexing; # the raw data for $desc_list
	my %set_frames; # the frames for the feature sets
	my %set_lbs; # the HLists for the feature sets
	my $new_desc; # the contents of the "new desc" entry box
	my $refine_rot; # blazon box (ROText)
	
	sub Refine_Cats
	{
		unless (defined $refine_dlog)
		{
			$refine_dlog = $mw->DialogBox;
			$refine_dlog->title('Edit features');
			my $item_f = $refine_dlog->add('Frame', -borderwidth => 2,
				-relief => 'ridge',
				)->pack(qw/-side top -fill x -expand yes/);
			$item_f->LabEntry(-label => 'Name',
				-labelPack => [qw/-side left -anchor w/],
				-width => 60,
				-textvariable => \$name,
				-font => $font,
				-relief => 'flat',
				-state => 'disabled',
				)->pack(qw/-side top -fill x -expand yes -anchor w/);
			$refine_rot = $item_f->ROText(
				-width => 120,
				-height => 2,
				-font => $font,
				-wrap => 'word',
				)->pack(qw/-side top -fill x -expand yes -anchor w/);
			my $control_f = $refine_dlog->add('Frame', -borderwidth => 2,
				-relief => 'ridge',
				)->pack(qw/-side bottom -fill x -expand yes/);
			$refine_dlog->add('LabEntry', -label => 'New Desc',
				-labelPack => [qw/-side left -anchor w/],
				-textvariable => \$new_desc,
				-width => 60,
				)->pack(qw/-side bottom -fill x -expand yes -anchor w/);
			my $desc_f = $refine_dlog->add('Frame',
				)->pack(qw/-side left -fill y -expand yes -anchor w/);
			$desc_list = $desc_f->Scrolled('HList',
				-scrollbars => 'se', 
				-selectmode => 'single',
				-drawbranch => 0,
				-indicator => 0,
				-width => 40,
				-height => 21,
				-browsecmd => \&Adjust_Features,
			-font => $font,
				)->pack(qw/-side left -expand yes -fill y -anchor w/);
			foreach my $set (keys %set_names)
			{
				$set_frames{$set} = $refine_dlog->add('Frame', -label => $set,
					-labelPack => [qw/-side top -anchor w/],
					);
				$set_lbs{$set} = $set_frames{$set}->Scrolled('HList', -scrollbars => 'se',
					-drawbranch => 0,
					-indicator => 0,
					-width => 20,
					-selectmode => 'single',
					-font => $font,
					-height => 20,
					-browsecmd => \&Adjust_Feature,
					)->pack(qw/-side left -expand yes -fill y -anchor w/);
				foreach my $i ('<none>', @feature_names)
				{
					next unless ($i eq '<none>' or $set_name{$i} eq $set);
					$set_lbs{$set}->add($i, -text => $i);
				}
				
			}
			
			$control_f->Button(-text => 'Prev Blazon',
				-command => sub { Prev_Item(); Adjust_Desc_List(); },
				)->pack(qw/-side left/);
			$control_f->Button(-text => 'Prev Desc',
				-command => \&Prev_Desc,
				)->pack(qw/-side left/);
			$control_f->Button(-text => 'Next Desc',
				-command => \&Next_Desc,
				)->pack(qw/-side left/);
			$control_f->Button(-text => 'Next Blazon',
				-command => sub { Next_Item(); Adjust_Desc_List(); },
				)->pack(qw/-side left/);
			$control_f->Button(-text => 'Add Desc',
				-command => \&Add_Desc,
				)->pack(qw/-side right/);
		}
		Adjust_Desc_List();
		$refine_dlog->Show;
	}
	
	sub Adjust_Desc_List
	{
		$refine_rot->delete('1.0', 'end');
		$refine_rot->insert('1.0', $blazon);
		$desc_list->delete('all');
		@indexing = ();
		foreach my $f (keys %current_descs)
		{
			push @indexing, @{$current_descs{$f}};
		}
		return unless @indexing;
		foreach my $i (0..$#indexing)
		{
			$desc_list->add($i, -text => $indexing[$i]);
		}
		$desc_list->anchorClear;
		$desc_list->selectionClear;
		$desc_list->selectionSet(0);
		$desc_list->see(0);
		Adjust_Features();
	}
	
	sub Adjust_Feature
	{
		my $sel = ($desc_list->selectionGet)[0];
		my $curr_desc = $desc_list->itemCget($sel, 0, -text);
		my ($head, @feats) = split(/:/, $curr_desc);
		
		my $desc = $head;
		foreach my $df (@{$categories{$head}->{features}})
		{
			my $feat = ($set_lbs{$df}->selectionGet)[0];
			$desc .= ":$feat" unless $feat eq '<none>';
		}
		$desc_list->itemConfigure($sel, 0, -text => $desc);
		$indexing[$sel] = $desc;
		
		%current_descs = ();
		foreach my $i (@indexing)
		{
			my ($head) = split(/:/, $i);
			#print STDERR 'Adjust_Feature: push @{$current_descs{', $head, '}}, ', $i, "\n";
			push @{$current_descs{$head}}, $i;
			$categories{$head}->{value} = 1;
		}
		
	}
	
	sub Adjust_Features
	{
		my $sel = ($desc_list->selectionGet)[0];
		my $curr_desc = $desc_list->itemCget($sel, 0, -text);
		my ($head, @feats) = split(/:/, $curr_desc);
		foreach my $df (sort keys %set_frames)
		{	
			$set_frames{$df}->packForget;
		}
		foreach my $df (@{$categories{$head}->{features}})
		{
			$set_frames{$df}->pack(qw/-side left -expand yes -fill y -anchor w/);
			$set_lbs{$df}->selectionClear;
			$set_lbs{$df}->anchorClear;
			$set_lbs{$df}->selectionSet('<none>');
			$set_lbs{$df}->see('<none>');
		}
		foreach my $feat (@feats)
		{
			next unless defined $feat;
			my $df = $set_name{$feat};
			$set_lbs{$df}->selectionClear;
			$set_lbs{$df}->anchorClear;
			$set_lbs{$df}->selectionSet($feat);
			$set_lbs{$df}->see($feat);
		}
	}
	
	sub Next_Desc
	{
		my $sel = ($desc_list->selectionGet)[0];
		++$sel; $sel %= scalar(@indexing);
		$desc_list->anchorClear;
		$desc_list->selectionClear;
		$desc_list->selectionSet($sel);
		$desc_list->see($sel);
		Adjust_Features();
	}
	
	sub Prev_Desc
	{
		my $sel = ($desc_list->selectionGet)[0];
		--$sel; $sel %= scalar(@indexing);
		$desc_list->anchorClear;
		$desc_list->selectionClear;
		$desc_list->selectionSet($sel);
		$desc_list->see($sel);
		Adjust_Features();
	}
	
	sub Add_Desc
	{
		my ($head) = split(/:/, $new_desc);
		return unless exists $categories{$head}; # reject non-existent categories
		#print STDERR 'Add_Desc: push @{$current_descs{', $head, '}}, ', $new_desc, "\n";
		push @{$current_descs{$head}}, $new_desc;
		$categories{$head}->{value} = 1;
		$items[$current_item-1] .= '|'.$new_desc;
		(undef, undef, undef, undef, undef, @indexing) = split(/[|]/, $items[$current_item-1]);
		$desc_list->add($#indexing, -text => $new_desc);
		$desc_list->selectionClear;
		$desc_list->anchorClear;
		$desc_list->selectionSet($#indexing);
		$desc_list->see($#indexing);
		Adjust_Features();
	}
}

{	
	my $find_dlog;
	my $find_string;
	my $find_list;
	sub Find_Synonym
	{
		unless (defined $find_dlog)
		{
			$find_dlog = $mw->Toplevel;
			$find_dlog->title("Synonym lookup");
			my $entry = $find_dlog->LabEntry(-label => 'Find:',
				-labelPack => [qw/-side left -anchor w/],
				-textvariable => \$find_string,
				-width => 40,
				)->pack(qw/-side top -expand yes -fill x -anchor w/);
			$entry->bind('<Return>', \&Update_Synonym);
			
			$find_list = $find_dlog->Scrolled('Listbox', -scrollbars => 'se',
				-width => 50,
				-height => 10,
				)->pack(qw/-side top -fill both -expand yes/);
		}
		$find_dlog->raise;
		$find_dlog->deiconify;
	}
	
	sub Update_Synonym
	{
		$find_list->delete(0, 'end');
		foreach my $l (@xref{grep /$find_string/, keys %xref})
		{
			$find_list->insert('end', @$l);
		}
	}
}
